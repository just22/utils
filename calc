#!/bin/sh

# ----------------------------------------------------------------------
#  $Id$
#
#  Simple calculator with (optional) ENG notation (using awk as backend)
# ----------------------------------------------------------------------

_usage() {
        echo "Usage: $(basename $0): -h | [-n|-s] [-p <precision>] <expr>"
        echo "       -h: This help message"
        echo "       -n: Do not use ENG notation"
        echo "       -s: Use ENG notation with SI prefixes"
        echo "       -p <n>: User-defined precision (default: 3)"
}

eng_fmt() {
        IFS="E" read mant exp <<- EOT
		$1
	EOT

        # Convert exp in a signed integer
        exp="$(awk "BEGIN {printf \"%d\", ${exp:-0}}")"

        while [ $(($exp % 3)) -ne 0 ]; do
                mant="$(awk "BEGIN {printf \"%.15f\", $mant * 10}")"
                exp="$(($exp - 1))"
        done
        if [ "$exp" -eq 0 ]; then
                exp=""
        elif [ "$use_prefix" -eq 1 ]; then
                case "$exp" in
                 15) exp=P ;;   # peta
                 12) exp=T ;;   # tera
                  9) exp=G ;;   # giga
                  6) exp=M ;;   # mega
                  3) exp=k ;;   # kilo
                 -3) exp=m ;;   # milli
                 -6) exp=u ;;   # micro
                 -9) exp=n ;;   # nano
                -12) exp=p ;;   # pico
                -15) exp=f ;;   # femto
                  *) exp=E$1
                esac
        else
                exp="E$exp"
        fi
        printf "%.${p}f%s\n" "$mant" "$exp"
}


# Main
# ----------------------------------------------------------------------

# Defaults
fmt=E           # ENG notation
use_prefix=0    # No SI prefixes
p=3             # 3-digit precision

# Command line non-positional arguments parsing
if [ "$1" == -h ]; then
        >&2 _usage
        exit 0
fi
while getopts ":snp:" arg; do
        case "$arg" in
        n) fmt=f        ;;
        s) use_prefix=1 ;;
        p) p="$OPTARG"  ;;
        esac
done
shift $(($OPTIND - 1))

# Remaining positional arguments are the expression's terms
in_expr="$(echo "$*" |
           sed -E -e "s/([0-9]+\.?[0-9]*)P/(\1*10^15)/g;   \
                      s/([0-9]+\.?[0-9]*)T/(\1*10^12)/g;   \
                      s/([0-9]+\.?[0-9]*)G/(\1*10^9)/g;    \
                      s/([0-9]+\.?[0-9]*)M/(\1*10^6)/g;    \
                      s/([0-9]+\.?[0-9]*)k/(\1*10^3)/g;    \
                      s/([0-9]+\.?[0-9]*)m/(\1*10^-3)/g;   \
                      s/([0-9]+\.?[0-9]*)u/(\1*10^-6)/g;   \
                      s/([0-9]+\.?[0-9]*)n/(\1*10^-9)/g;   \
                      s/([0-9]+\.?[0-9]*)p/(\1*10^-12)/g;  \
                      s/([0-9]+\.?[0-9]*)f/(\1*10^-15)/g")"

# Prefixes in input expression?
[ "$in_expr" != "$*" ] && use_prefix=1

# Run computation, exit on errors
res="$(awk "BEGIN {printf \"%.15$fmt\", $in_expr}" 2>/dev/null)"
if [ "$?" -ne 0 ]; then
        >&2 echo "$(basename "$0"): Expression evaluation error"
        exit 1
fi

# Result formatting
eng_fmt "$res"

exit 0
