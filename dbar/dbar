#!/bin/sh

# Relies on 'unbuffer' command (OpenBSD package: expect)
#
# This script is a module-based dzen2 master script. The modules push their
# changes to dzen2 when a change occurs, triggering a redraw. No redraws
# happen unless a module pushes a change. Modules are just programs of any
# kind. To add your own module, write a script that produces output for dzen2
# and put it in ~/.config/dbar directory.
#
# dzen2 customization
BG="#eee8d5"
FG="#073642"
FN="-*-dejavu sans mono-medium-r-*-*-12-*-*-*-*-*-*-*"
H=17

# Use -d option to print module outputs to stderr
[ "$1" == "-d" ] && DEBUG=1

# The status bar layout
layout='cpu_mem load sd0 trunk0 batt'

# Clean up
pkill -P "$(cat /tmp/dbar.pid)"
rm /tmp/dbar_p

echo "Running $(basename $0) with PID $$"
echo "$$" > /tmp/dbar.pid

cd ~/.config/dbar || { echo "~/dbar module dir doesn't exists" >&2; exit 1; }

# Make a pipe to multiplex inputs from the module scripts
mkfifo /tmp/dbar_p || { echo "Cannot create /tmp/dbar_p" >&2; exit 1; }

# Start modules, piping them to dbar_p
for mod in $layout; do
	unbuffer mod_$mod | unbuffer -p sed "s/^/MODULE $mod /g" > /tmp/dbar_p &
done

# Main loop
# A simple associative array (curr_s) keeps track of the last string
# returned by every module script.
# The output of print_status_bar is simply the concatenation of all the
# strings. Output from awk is piped into dzen2.
awk -v DEBUG="$DEBUG" -v layout_string="$layout" '
	function print_status_bar() {
		for (i = 1; i <= mod_no; i++) {
			s = curr_s[mod_list[i]];
			sub(/\r/, "", s);
			printf("  %s", s);
		}
		printf("\n");
		fflush();
	}
	BEGIN {
		mod_no = split(layout_string, mod_list, " ");
	}
	/^MODULE/ {
		if (DEBUG == 1) { print $0 > ("/dev/stderr") }
		curr_s[$2]=substr($0, length($1 $2) + 3, length($0));
		print_status_bar();
	}
' < /tmp/dbar_p |
dzen2 -title-name dbar \
      -bg "$BG" -fg "$FG" -fn "$FN" \
      -p -e "" -expand left -dock \
      "$@"

