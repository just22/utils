#!/bin/sh

# ----------------------------------------------------------------------
#  $Id$
#
#  This is a simple module-based text-only starusbar.
#  Modules (just programs of any kind) push their changes to stdout when
#  a change occurs, triggering a redraw. A module is simply a script
#  that produces output (it must be placed in ~/.config/dbar directory).
#
#  Dependencies: unbuffer(1) (OpenBSD package: expect)
# ----------------------------------------------------------------------

set -e
set -o pipefail

npipe=/tmp/$USER.dbar_pipe

trap "fuser -k $npipe 2>/dev/null; rm $npipe" HUP INT KILL TERM PIPE

err() {
        echo "$1" >&2
        return 1
}

CONFDIR=~/.config/dbar

# Command line non-positional arguments parsing
while getopts ":hc:dm:x-" arg; do
        case "$arg" in
        h)
                echo "Usage: ${0##*/} [-h] | [-d] [-m string ...] [-x]"
                echo "  -c path    Configuration dir (defaults to ~/.config/dbar)"
                echo "  -d:        Debug mode (print module output to stderr)"
                echo "  -m string: Display output from module dbar_mod_<string>"
                echo "  -x:        Change xroot name (else, print to stdout)"
                exit 0
                ;;
        c)
                CONFDIR="$OPTARG"
                ;;
        d)
                DEBUG=1
                ;;
        m)
                layout="$layout $OPTARG"
                ;;
        x)
                XROOTN=1
                ;;
        :)
                err "${0##*/}: Option -$OPTARG requires an argument"
                ;;
        \?)
                err "${0##*/}: Unknown option: -$OPTARG"
        esac
done

# The status bar layout
layout=${layout:-"cpu_mem load sd0 trunk0 mixer batt"}

if ! cd ${CONFDIR} 2>/dev/null; then
        err "$CONFDIR not found"
fi

# Clean-up (just in case other instances of dbar are running)
if fuser -k $npipe >/dev/null 2>&1; then
        pkill -KILL -fl "/bin/sh ./dbar_mod_" >/dev/null 2>&1
        rm $npipe
fi

# Make a pipe to multiplex inputs from the module scripts
if ! mkfifo $npipe 2>/dev/null; then
        err "Cannot create $npipe"
fi

# Start modules, piping them to named pipe
for mod in $layout; do
        unbuffer dbar_mod_$mod |
        unbuffer -p sed "s/^/MODULE $mod /g" > $npipe &
done

# Main loop
# A simple associative array (curr_s) keeps track of the last string
# returned by every module script.
# The output of print_status_bar is simply the concatenation of all the
# strings.
awk -v DEBUG="$DEBUG" -v XROOTN="$XROOTN" -v layout_string="$layout" '
        function print_status_bar() {
                l=""
                for (i = 1; i <= mod_no; i++) {
                        s = curr_s[mod_list[i]];
                        sub(/\r/, "", s);
                        l = l s " ";
                }
                if (XROOTN == 1) {
                        system("xsetroot -name ""\""l"\"");
                } else {
                        printf("%s\n", l);
                        fflush();
                }
        }
        BEGIN {
                mod_no = split(layout_string, mod_list, " ");
        }
        /^MODULE/ {
                if (DEBUG == 1) {
                        print $0 > ("/dev/stderr")
                } else {
                        curr_s[$2]=substr($0, length($1 $2) + 3, length($0));
                        print_status_bar();
                }
        }
' < $npipe
