#!/bin/sh

# ----------------------------------------------------------------------
#  $Id$
#
#  LOG ANalyzer - Log files analysis and statistics
# ----------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Copyright 2017 Alessandro De Laurenzis
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
# this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
# contributors may be used to endorse or promote products derived from this
# software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

_help() { exec less << __HELP__
NAME
  logan - LOG ANalyzer (and Wolverine's human side, of course!)

SYNOPSIS
  logan -p pattern -c pattern [-g string] [-o string] [-i file] logFile
  logan -t tool [-g string] [-o string] [-i file] logFile

DESCRIPTION
  Logan scans logFile, selecting lines that match a specific pattern, provided
  by the user or based on the tool generating the log.  A code pattern may also
  be used to arrange matching lines by classes.  Some results may be removed
  from the report (when considered "safe") adding their code in a file.  An
  ordered list of matches is presented, sort operation being based on code
  (when relevant), or on first 25 description's chars).

  From the main menu, user is allowed to perform the following operations:
  - view all the occurrences of a specific match;
  - remove a line from the list of matches;
  - view the whole logFile;
  - toggle on/off the safe-known messages visibility;
  - re-do log file analysis.

  When user requests to view the occurrences of a specific match, a new screen
  is shown with relevant logFile's lines surrounded by minimal context.

  Modifications to logFile are not allowed.

  The following options are available:

  -p pattern   A regex representing the pattern to match;

  -c pattern   A regex representing the code pattern for each specific match;

  -t tool      The tool that is generating the logFile; possible values are:
               dc      - Synopsys(R) Design Compiler(R);
               pt      - Synopsys(R) PrimeTime(R);
               innovus - Cadence(R) Innovus(TM) Implementation System;
               nc      - Cadence(R) Incisive(R) Enterprise Simulator;

  -g string    Grep utility command name (defaults to "grep");

  -o string    Non-POSIX grep's options (defaults to "--color=always -T");

  -i file      A file containing a list of codes to be ignored, one per line.

  Logan always interprets patterns as extended regular expressions (ERE).


EXIT STATUS
  Logan exits with one of the following values:
    0: Script completed with no error;
    1: Unknown option, missing or non-existing file, pattern not specified.

EXAMPLES
  To find all error/warning messages in a log generated by Synopsys DC:

    $> logan -t dc logFile

  To specify a file of safe-known messages for Cadence Innovus:

    $> logan -t innovus -i safeMsgFile logFile

  To find all lines starting with "info:" and having an id code
  in the form "(ID-nnn)":

    $> logan -p "^\*info:" -c "\(ID-[0-9]+\)" logFile

SEE ALSO
grep(1), awk(1), sed(1), less(1)

AUTHOR
  Written by Alessandro De Laurenzis <just22@atlantide.t28.net>

__HELP__
}

analyze() {
        # Match logFile's lines againts pattern
        echo "Analyzing file, please wait..."
        allLines="$(match)"

        # If ignoreFile is specified, obtain unsafeLines removing its content from allLines,
        # otherwise all lines are considered "unsafe"
        if [ -n "$ignoreFile" ]; then
                unsafeLines="$(echo "$allLines" | ${grepCmd-grep} -Ev "$(cat $ignoreFile)")"
        else
                unsafeLines="$allLines"
        fi

        # Exit if no occurrences of specified pattern found
        if [ -z "$allLines" ]; then
                echo "No occurrences of \"$pattern\" in $logFile"
                exit 0
        fi

        # By default, list all matches
        unsafeOnly=0
        matchList="$(echo "$allLines" | cat -n)"
}

csort() {
        ptrn="$(echo "$1" | head -1 | awk '{print $1}')"
        echo "$1" | grep "$ptrn"
        nlist="$(echo "$1" | grep -v "$ptrn")"
        [ -n "$nlist" ] && csort "$nlist"
}

match() {
        # logFile line's anatomy:
        # [... descr ...] <pattern> [... descr ...] [<codePattern>] [... descr ...]
        #
        # List format:
        # Match #occur code|N/A descr
        #
        m=$(awk -v p="$(echo $pattern | sed -e 's/\\/\\\\\\/')" \
                -v cp="$(echo $codePattern | sed -e 's/\\/\\\\\\/')" \
                -v cols="$(($(tput cols) - 36))" '
                $0 ~ p  {
                        if (cp != "") match($0, cp, arr);
                        if (arr[0] != "") {
                                code = arr[0];
                                sub(cp, "")
                                sub(/^[[:space:]]+/, "");
                                sub(/[[:space:]]+$/, "");
                                gsub(/[[:space:]]+/, " ");
                        } else
                                code = "N/A";
                        if (length($0) > cols) $0 = substr($0, 1, (cols - 3)) "...";
                        printf "%-15s %s\n", code, $0
                }' "$logFile" 2>/dev/null)
        m_sorted="$(csort "$m")"
        m_coded=$(echo "$m_sorted" | grep -v "^N/A ")
        m_nocode=$(echo "$m_sorted" | grep "^N/A ")

        # Classified lines: uniq based on code
        [ -n "$m_coded" ]  && echo "$m_coded" | uniq -c -w 15

        # Unclassified lines: uniq based on description's first 25 chars
        [ -n "$m_nocode" ] && echo "$m_nocode" | uniq -c -w 41
}

list() {
        clear
        [ "$unsafeOnly" == 1 ] && msgTail=" (unsafe only)" || msgTail=""
        echo "List of \"$pattern\" occurrences${msgTail}:"
        echo
        echo "$matchList" |
        awk '
                BEGIN {
                        print "Match   #Occur   Code              Description";
                        print "-----   ------   ---------------   -------------------------------------"
                }

                {
                        printf "%5s   %6s   %-15s   ", $1, $2, $3;
                        for (i = 4; i <= NF; i++) {printf "%s ", $i}; printf "\n"
                }
        '
}

menu() {
        echo "------------------------------------------------------------------------"
        echo "Insert match number to show pattern occurrences with minimal context"
        echo "(prepend it with \"-\" to remove the line from list), or:"
        echo "'v' to view log file"
        echo "'t' to toggle on/off safe-known patterns visibility"
        echo "'r' to re-do log file analysis"
        echo "'q' to exit"
        echo "------------------------------------------------------------------------"
        echo
}

show() {
        if [ "$action" -ge 1 ] && [ "$action" -le $(echo "$matchList" | wc -l) ]; then

                # Select ${action}th line of match-set
                sel="$(echo "$matchList" | sed -e "${action}q;d")"
                if [ "$(echo "$sel" | awk '{print $3}')" == "N/A" ]; then
                        # Unclassified line: search for description's first 25 chars
                        #       "<- 15  chars ->"
                        # (code="N/A <-12space->", 12 + 25 = 37
                        s_str="$(echo "$sel" |
                                 awk -F " N/A " '{print substr($2, 1, 37)}' |
                                 sed -E -e "s/^\s+//")"
                else
                        # Classified line: search for code
                        s_str="$(echo "$sel" | awk '{print $3}')"
                fi
                ${grepCmd-grep} ${grepOpt---color=always -T} -F -C 3 -n "$s_str" "$logFile" | less -R
        fi
}


# ----------------------------------------------------------------------
# Main
#

# Command line non-positional arguments parsing
while getopts ":ht:p:c:g:o:i:" arg; do
        case "$arg" in
        h)
                _help
                ;;
        t)
                case "$OPTARG" in
                dc|pt)
                        pattern="^Error:|^Warning:"
                        codePattern="\([A-Z]+-[0-9]+\)$"
                        ;;
                innovus)
                        pattern="^\*\*ERROR:|^\*\*WARN:|^Error:|^Warning:"
                        codePattern="\([A-Z]+-[0-9]+\):"
                        ;;
                nc)
                        # "Hackish" patterns to match UVM error/warnings and
                        # timing violations
                        pattern="\*[E,W]|^Error|^Warning|_WARNING|_ERROR"
                        codePattern="\*[E,W],[A-Za-z0-9]+:|[A-Za-z0-9]+_WARNING|[A-Za-z0-9]+_ERROR"
                        #
                        # For tool's native E/W msgs only:
                        #pattern="\*[E,W]"
                        #codePattern="\*[E,W],[A-Za-z0-9]+:"
                        ;;
                *)
                        >&2 echo "$(basename $0): Unknown tool: $OPTARG"
                        exit 1
                esac
                ;;
        p)
                pattern="$OPTARG"
                ;;
        c)
                codePattern="$OPTARG"
                ;;
        g)
                grepCmd="$OPTARG"
                ;;
        o)
                grepOpt="$OPTARG"
                ;;
        i)
                ignoreFile="$OPTARG"
                if [ ! -f "$ignoreFile" ]; then
                        >&2 echo "$(basename $0): cannot stat $ignoreFile: No such file"
                        exit 1
                fi
                ;;
        :)
                echo "$(basename $0): Option -$OPTARG requires an argument"
                exit 1
                ;;
        \?)
                echo "$(basename $0): Unknown option: -$OPTARG"
                exit 1
        esac
done
shift $(($OPTIND - 1))

# Remaining positional argument is supposed to be the logFile
if [ "$#" -ne 1 ]; then
        >&2 echo "$(basename $0): Missing logFile"
        >&2 echo "Try \"$(basename $0) -h\" for more info"
        exit 1
fi
logFile="$1"

# Check if logFile exists
if [ ! -f "$logFile" ]; then
        >&2 echo "$(basename $0): cannot stat $logFile: No such file"
        exit 1
fi

# Check if pattern has been defined
if [ -z "$pattern" ]; then
        >&2 echo "$(basename $0): Missing pattern or tool"
        >&2 echo "Try \"$(basename $0) -h\" for more info"
        exit 1
fi

# less(1) options: clear the screen and ignore filters
LESS="-c"; LESSOPEN=

# Analyze log file
analyze

# Main loop (q to exit)
while true; do
        list    # List of matches
        menu    # User actions

        echo -n "What now? "; read action
        case "$action" in
        v)
                # View logFile
                less "$logFile"
                ;;
        [0-9]*)
                # Show occurrences with context
                show
                ;;
        -[0-9]*)
                # Remove entry from list of matches
                allLines="$(echo "$allLines" | sed -e "${action#-}d")"
                matchList="$(echo "$allLines" | cat -n)"
                ;;
        t)
                # Toggle on/off safe-known patterns visibility
                if [ "$unsafeOnly" -eq 1 ]; then
                        unsafeOnly=0;
                        matchList="$(echo "$allLines" | cat -n)"
                elif [ -z "$unsafeLines" ]; then
                        echo -n "No unsafe patterns match. Hit ENTER to continue "; read
                else
                        unsafeOnly=1;
                        matchList="$(echo "$unsafeLines" | cat -n)"
                fi
                ;;
        r)
                analyze
                ;;
        q)
                exit 0
        esac

done
