#!/bin/sh

# ----------------------------------------------------------------------
#  $Id$
#
#  LOG ANalyzer - Log files analysis and statistics
# ----------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Copyright 2017 Alessandro De Laurenzis
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
# this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
# contributors may be used to endorse or promote products derived from this
# software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# ----------------------------------------------------------------------------

_help() { cat << HELP
NAME
  logan - LOG ANalyzer (and Wolverine's human side, of course!)

SYNOPSIS
  logan -p pattern -c pattern [-g string] [-o \string\] [-i file] file
  logan -t tool [-g string] [-o \string\] [-i file] file

DESCRIPTION
  The logan utility seaches the input file, selecting lines that match a
  specific pattern, provided by the user or automatically selected basing on
  the tool generating the file.  A code pattern may be also checked in order
  to make a taxonomy of matching lines.  Some results may be removed from the
  report (when considered "safe") adding their code in a file.  From the main
  menu, user is allowed to perform these operations:
  - view all the occurrences of a specific match, with a minimal context;
  - view the whole file;
  - toggle on/off the safe-known message visibility.

  Modifications to log file are not allowed.

  The following options are available:

  -p pattern   A regex representing the pattern to match;

  -c pattern   A regex representing the code pattern for each specific match;

  -t tool      The tool that is generating the log file; possible values are:
  dc      - Synopsys Design Compiler; pt      - Synopsys PrimeTime suite;
  innovus - Cadence Innovus Digital Implementation System;

  -g string    A string containing the command used as grep utility (defaults
  to "grep");

  -o string    A string containing the non-POSIX grep's options (defaults to
  "--color=always -T");

  -i file      A file containing a list of codes to be ignored, one per line.

  Logan always interprets patterns as extended regular expressions (ERE).


EXIT STATUS
  The logan utility exits with one of the following values:
    0: Script completed with no error;
    1: Unknown option, missing or non-existing file, pattern not specified.

EXAMPLES
  To find all error/warning messages in a log generated by Synopsys DC:

    $> logan -t dc logFile

  To specify a file of safe-known messages for Cadence Innovus:

    $> logan -t innovus -i safeMsgFile logFile

  To find all lines starting with "info:" and having an id code
  in the form "(ID-nnn)":

    $> logan -p "^\*info:" -c "\(ID-[0-9]+\)" logFile

SEE ALSO
grep(1), awk(1)

AUTHOR
  Alessandro De Laurenzis, <alessandro.de-laurenzis@st.com>
  MSD - MEMS Sensors Division
  AMG - Analog & MEMS Group
  STMicroelectronics
HELP
}

match() {
        # Line's anatomy:
        # [... desc ...] <pattern> [... desc ...] [<codePattern>] [... desc ...]
        #
        # List format:
        # Line# #occur code|N/A desc
        #
        awk -v p="$(echo $pattern | sed -e 's/\\/\\\\\\/')" \
            -v cp="$(echo $codePattern | sed -e 's/\\/\\\\\\/')" '
                $0 ~ p  {
                        if (cp != "") match($0, cp, arr);
                        if (arr[0] != "") {
                                code = arr[0];
                                sub(cp, "")
                        } else
                                code = "N/A";
                        sub(/^[[:space:]]+/, "");
                        sub(/[[:space:]]+$/, "");
                        gsub(/[[:space:]]+/, " ");
                        if (length($0) > 100) $0 = substr($0, 1, 97) "...";
                        printf "%s %s\n", code, $0
                }
        ' "$logFile" 2>/dev/null |
        sort | uniq -c -w 25
}

list() {
        clear
        [ "$unsafeOnly" == 1 ] && msgTail=" (unsafe only)" || msgTail=""
        echo "List of \"$pattern\" occurrences${msgTail}:"
        echo
        echo "$matchList" |
        awk '
                BEGIN {
                        print "Line#   #Occur   Code              Description";
                        print "-----   ------   ---------------   -------------------------------------"
                }

                {
                        printf "%5s   %6s   %-15s   ", $1, $2, $3;
                        for (i = 4; i <= NF; i++) {printf "%s ", $i}; printf "\n"
                }
        '
}

menu() {
        echo "------------------------------------------------------------------------"
        echo "Insert line number to show pattern matches (with context), or:"
        echo "'v' to view log file"
        echo "'t' to toggle safe-known patterns visibility"
        echo "'q' to exit"
        echo "------------------------------------------------------------------------"
        echo
}

show() {
        if [ "$action" -ge 1 ] && [ "$action" -le $(echo "$matchList" | wc -l) ]; then
                sel="$(echo "$matchList" |
                       head -n "$action" | tail -n 1)"
                if [ "$(echo "$sel" | awk '{print $3}')" == "N/A" ]; then
                        sp="$(echo $sel | awk '{$1=$2=$3=""; print substr($0, 1, 25)}' |
                                          sed -E -e "s/^\s+//; s/ \.\.\.$//")"
                else
                        sp="$(echo $sel | awk '{print $3}')"
                fi
                ${grepCmd-grep} ${grepOpt---color=always -T} -E -C 3 -n "$sp" "$logFile" | less -R
        fi
}


# ----------------------------------------------------------------------
# Main
#

# Command line non-positional arguments parsing
if [ "$1" == -h ]; then
        >&2 _help
        exit 0
fi
while getopts ":p:t:g:o:i:" arg; do
        case "$arg" in
        p)
                pattern="$OPTARG"
                ;;
        t)
                case "$OPTARG" in
                dc|pt)
                        pattern="^Error:|^Warning:"
                        codePattern="\([A-Z]+-[0-9]+\)$"
                        ;;
                innovus)
                        pattern="^\*\*ERROR:|^\*\*WARN:"
                        codePattern="\([A-Z]+-[0-9]+\):"
                        ;;
                *)
                        >&2 echo "$(basename $0): Unknown tool: $OPTARG"
                        exit 1
                esac
                ;;
        c)
                codePattern="$OPTARG"
                ;;
        g)
                grepCmd="$OPTARG"
                ;;
        o)
                grepOpt="$OPTARG"
                ;;
        i)
                ignoreFile="$OPTARG"
                if [ ! -f "$ignoreFile" ]; then
                        >&2 echo "$(basename $0): cannot stat $ignoreFile: No such file"
                        exit 1
                fi
                ;;
        :)
                echo "$(basename $0): Option -$OPTARG requires an argument"
                exit 1
                ;;
        \?)
                echo "$(basename $0): Unknown option: -$OPTARG"
                exit 1
        esac
done
shift $(($OPTIND - 1))

# Remaining positional argument is supposed to be the logFile
if [ "$#" -ne 1 ]; then
        >&2 echo "$(basename $0): Missing logFile"
        >&2 echo "Try \"$0 -h\" for more info"
        exit 1
fi
logFile="$1"

# Check for logFile existance
if [ ! -f "$logFile" ]; then
        >&2 echo "$(basename $0): cannot stat $logFile: No such file"
        exit 1
fi

# Check if pattern has been defined
if [ -z "$pattern" ]; then
        >&2 echo "$(basename $0): Missing pattern or tool"
        >&2 echo "Try \"$0 -h\" for more info"
        exit 1
fi

# Switch off LESS filters
LESSOPEN=

# Match logFile's lines againts pattern
echo "Analyzing file, please wait..."
allLines="$(match)"
if [ -n "$ignoreFile" ]; then
        unsafeLines="$(echo "$allLines" | ${grepCmd-grep} -Ev "$(cat $ignoreFile)")"
else
        unsafeLines="$allLines"
fi

if [ -z "$allLines" ]; then
        echo "No occurrences of \"$pattern\" in $logFile"
        exit 0
fi
unsafeOnly=0
matchList="$(echo "$allLines" | cat -n)"

while true; do
        list    # List of matches
        menu    # User actions

        echo -n "What now? "; read action
        case "$action" in
        v)
                ${PAGER:-less} "$logFile"
                ;;
        [0-9]*)
                show    # Show matching lines with context
                ;;
        t)
                if [ "$unsafeOnly" -eq 1 ]; then
                        unsafeOnly=0;
                        matchList="$(echo "$allLines" | cat -n)"
                elif [ -z "$unsafeLines" ]; then
                        echo -n "No unsafe patterns match. Hit ENTER to continue "; read
                else
                        unsafeOnly=1;
                        matchList="$(echo "$unsafeLines" | cat -n)"
                fi
                ;;
        q)
                exit 0
        esac

done
